<h1>Native Responsive Images</h1>

<h2>How It All Began</h2>

<p>Our story starts in ancient times, when WURFLs roamed the wilderness,
and mobile-only Web sites were a thing. In these times, a developer that
wanted to provide access to his Web site to mobile users created a
simpler, dumbed down version of the "real" Web site, and served that
based on UA detection.</p>

<p>As you surely know, the proliferation of devices with numerous viewport dimensions and many different
capabilities called out for a better way to target mobile (and
not-so-mobile) users. <a href="http://alistapart.com/article/responsive-web-design">Responsive Web
Design</a> combined new browser
capabilities and CSS techniques to create Web
sites that adapt to the device displaying them, and look ideal everywhere.
That enabled developers to stop worrying about unreliable device
detection and think of their Web sites in terms of viewport dimensions.</p>

<p>But, even though RWD sites <em>looked</em> different on each device,
underneath, <a href="http://www.guypo.com/uncategorized/real-world-rwd-performance-take-2/">most of them continued to download the same resources for all
devices</a>.
And since images <a href="http://httparchive.org/interesting.php#bytesperpage">comprised the major
part</a> of the bytes that Web
sites were downloading, the developer community started to look into possible
solutions to avoid this waste.</p>

<p>That started a (very) long process in which multiple proposals were suggested on
various mailing-lists, the problem was analyzed over <a href="http://blog.cloudfour.com/responsive-imgs/">blog
post</a> debates,
and the <a href="http://usecases.responsiveimages.org/">various use-cases</a> that emerged were taken into consideration.
The developer community united to form the <a href="http://responsiveimages.org/">Responsive Images
Community Group</a>, and eventually, browser vendors got involved and
consensus was reached.
The <a href="http://picture.responsiveimages.org/">picture element</a> specification that was written in collaboration between the
community and browser vendors was merged into the <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/embedded-content.html">HTML spec</a>, and both Blink &amp; Gecko's implementations are destined to ship early this fall!</p>

<p>But, hold on a minute. That's a great story and all, but why should I care about responsive images?
What can responsive images do for <em>me</em>?</p>

<h2>Fixed Width Images</h2>

<p>So, let's say that the Web site you're building has images that are
always of the same dimensions regardless of viewport size. E.g. the Web site you're building is not responsive.
The only thing "responsive" about these images is that you want them to look good on high-end devices with a higher Device-Pixel-Ratio 
(or DPR, as his parents fondly call him), but you don't want to send "retina images" to devices that don't need them.</p>

<p>Let's say that you have a 500px image. You want it to be displayed at these <em>same</em> dimensions on retina screens, only with higher quality.</p>

<p>The syntax that enables you to do that would look something like:</p>

<p><code>&lt;img src="cat_500px.jpg" srcset="cat_750px.jpg 1.5x, cat_1000px.jpg 2x" width="500px" alt="lolcat"&gt;</code></p>

<p>Short and sweet, right? No need for too many explanations there. You
just give the browser a comma-separated list of resources and their
'x' descriptors (describing the screen's DPR), and the browser picks the best fit.</p>

<p>Note that the 1x image resource is in the <code>src</code>
attribute, where it doubles as a fallback resource. There no need to
write the same resource twice!</p>

<h2>Variable Width Images</h2>

<p>Now, if your site is a "classical" responsive Web site with "stretchy"
images, the above is not enough.
It's better than nothing, sure, but a 1920px wide screen and a 360px
screen with the same density will get the same image, which means
you'll be making significant UX compromises, either on blurriness or
on slowness.</p>

<p>What you really want is to define the image resources in a way that
allows a browser to pick the right one for the current DPR and 
viewport size. But how can we do that???</p>

<p>Ideally, we'd want to define the set of available image resources along with their physical dimensions (i.e. their width in pixels), and
have the browser download one based on the image's display dimensions.</p>

<p>But there's a problem: The browser doesn't know what the image's display dimensions
will be when it needs to choose which resource to download.
The image's display dimensions depend on the final page's layout,
which often relies on external CSS, and can be influenced by the image's dimensions, as well as the
dimensions of other images on the page. That's some circularity madness
right there!!!</p>

<p>So, if we want the browser to download the right resource, we need to
provide it with a hint regarding the final display dimensions - there's
just no way around that. Of course, depending on our design, the image's
dimensions can vary at the various layouts. </p>

<p>These are rather complex constraints, which is one of the reasons it took a loooong while to get a proper definition of the problem.
Eventually, Google's <a href="https://twitter.com/tabatkins">Tab Atkins</a> and <a href="https://twitter.com/john__mellor">John Mellor</a>
came up with a proposal for a syntax that would resolve this "stretchy images" use case, and it was happily adopted into the overall responsive images spec 
(With Tab as well as <a href="https://twitter.com/zcorpan">Simon Pieters</a> from Opera doing most of the spec's editing).</p>

<p>Let's look at an example of what you would do if you have an image that
takes up different dimensions at different layout breakpoints:</p>

<pre><code>&lt;img sizes="(max-width: 30em) 100vw,
            (max-width: 50em) 50vw,
            calc(33vw - 100px)"
     srcset="swing-200.jpg 200w,
             swing-400.jpg 400w,
             swing-800.jpg 800w,
             swing-1600.jpg 1600w"
     src="swing-400.jpg" alt="Kettlebell Swing"&gt;</code></pre>

<p>That may seem overwhelming at first, so let's break it up into pieces.
The 'w' descriptors of the srcset syntax are not very different
from the 'x' descriptors that we saw earlier. 
The <code>srcset</code> attribute contains a grocery list of resources that the browser can
pick from, and the 'w' descriptors tell the browser each resource's physical dimensions.</p>

<p>But, didn't we just say that the browser cannot wait for the image's
display dimensions to be calculated because doing so would result in significant delays and possible double
downloads? And if the browser cannot wait for the display dimensions, how can
it use the image's physical dimensions to determine which resource to download?</p>

<p>This is where the <code>sizes</code> attribute comes into play.
It is comprised of value pairs, where the first (optional) value is a media
condition (a media query without the media type) and the second value is a
CSS length.</p>

<p>The browser goes over the media conditions and looks for the first one
that matches the current environment (in most cases, "current environment"
== current viewport). The second value of the pair (or the first one if the
media condition is missing), is set as the pair's "effective size", and
it describes the estimated display dimensions of the image. This is the
hint the developer has to give the browser in order for it to know which
resource to pick.</p>

<p>The effective size of the matching pair is used by the browser, along with the screen's
DPR (and possibly other factors) to figure out which resource would be
the best to download and display.</p>

<p>Going back to our code example above, assuming we're running with a browser viewport of 
20em over the default root font size of 16px (i.e. a viewport width of 320px), the browser will go over
the sizes pairs and pick the first one - <code>(max-width: 30em) 100vw</code>.
That would indicate it that the image is likely to be displayed at the
full width of the viewport, so assuming a DPR of 1, the browser is likely try to download the
first resource that is larger than 320px wide and end up downloading
swing-400.jpg.
If the DPR value is 2, in order to match the screen's density the required resource needs to be twice as large, 
so the browser will probably download the first resource larger than 640px, which is swing-800.jpg.</p>

<p>Now, if our viewport is 40em (640px), the <code>(max-width: 50em) 50vw</code> pair matches, and the image is likely to take up half of the
viewport's width. That means the image picked it probably the first one
larger than 320px for 1x screens and 640px for 2x screen, and the downloaded resources are likely to be identical in both cases.</p>

<p>Why did I use all of those "likely"s and "probably"s in the sections above?
They're there because for the resources <em>inside</em> srcset, the browser is free to pick whatever resource its algorithms
see fit. That means that you, as a Web developer, can't rely on the
browser downloading and displaying the exact resource you want it to.
That's a Good Thing<span>&trade;</span>, since it leaves the browser room to innovate in
this space, by adding user preferences, network considerations and other
future optimizations to the decision-making process. And
since all of the different resources should only differ in quality,
differing resource choices shouldn't have any impact on your page's layout.</p>

<p>It's worth noting that if the <code>sizes</code> attribute is missing, a default
value of <code>100vw</code> is used as the effective size instead, as it represents the
largest display dimensions the image might be displayed in without
horizontal scrolling.</p>

<p>So what happens if you want to see slightly different images on different layouts,
showing images whose proportions are different, whose subject is more
visible, or anything else your creative selves desire?</p>

<p>That's what the art direction use-case is all about!</p>

<h2>Art Direction</h2>

<p>The term "Art-Direction" with regard to responsive images was first
<a href="http://blog.cloudfour.com/a-framework-for-discussing-responsive-images-solutions/">coined</a> by <a href="https://twitter.com/grigs">Jason Grigsby</a>,
and refers to cases where you want to tailor-fit 
the displayed image to a specific responsive layout breakpoint.
Art-direction should be used when your image resources differ not only in their quality, but also in
their proportions, crop area, copy text location, shot angle,
etc, etc. The possibilities are limitless!</p>

<p>In these cases, you want to make sure that the image displayed to your users
at a certain design breakpoint is in fact the image you intended they'd
see.</p>

<p>The art-direction syntax goes something like:</p>

<pre><code>&lt;picture&gt;
  &lt;source media="(min-width: 45em)" srcset="large.jpg"&gt;
  &lt;source media="(min-width: 32em)" srcset="med.jpg"&gt;
  &lt;img src="small.jpg" alt="The president giving an award."&gt;
&lt;/picture&gt;</code></pre>

<p>Here again we hand out a grocery list of resources to the browser. The
difference is that this is a list of <code>&lt;source&gt;</code> tags, 
and <em>their</em> selection algorithm is <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/embedded-content.html#select-an-image-source">well-defined by the
spec</a>. </p>

<p>The browser follows that algorithm to the letter and picks
the source tag that you intended, every time.</p>

<p>Very much like it does when using the <code>sizes</code> algorithm, the browser goes over the
list of sources and picks the first one that matches. A match can happen
based on both <code>media</code> and <code>type</code> attributes. (Why <code>type</code>? We'll see that
in a bit)</p>

<p>If both attributes either match or are missing, the matching source is picked.
If none of the <code>&lt;source&gt;</code>s match, the <code>&lt;img&gt;</code> is picked.
And once we have an element that's picked as the source for this image, 
the resource that will be downloaded is chosen using the source's <code>srcset</code> and <code>sizes</code> attributes,
according to the same mechanisms we discussed earlier.</p>

<p>A few things to take note of:</p>

<ul>
<li><code>&lt;source src&gt;</code> does nothing, and is ignored during the selection process. Make sure you use <code>&lt;source srcset&gt;</code>.</li>
<li>Even though <code>picture</code> is the parent element, the element doing all the heavy lifting here
is the <code>&lt;img&gt;</code>. The <code>&lt;img&gt;</code> uses its <code>&lt;picture&gt;</code> parent and its elder <code>&lt;source&gt;</code> siblings to pick the
a resource to load, but eventually it is the <code>&lt;img&gt;</code> that is used to display
the resource.
That means that the <code>&lt;img&gt;</code> <em>must</em> be there, otherwise, no image will be
displayed on screen. That's also good for fallback purposes: the <code>&lt;img&gt;</code>
needs to be there in order to provide a fallback for 
older browsers, so it should be there anyway, but regardless, if the <code>&lt;img&gt;</code> is not there, nothing will
display.</li>
<li>Last but not least, if you want to style your image, you need to style <code>&lt;img&gt;</code> like
you always have. In the immortal words of Tab Atkins, you should think
of <code>&lt;picture&gt;</code> as a "magical span" around your <code>&lt;img&gt;</code>. Same goes for alt
text. It should go on your <code>&lt;img&gt;</code>, like it always has.</li>
</ul>

<h3>Why can't we do art-direction with <code>sizes</code>/<code>srcset</code>?</h3>

<p>By design, the <code>sizes</code>/<code>srcset</code> syntax takes
into account the viewport's width as well as the screen's DPR. Adding
art-direction into the same syntax would have meant that the Web
developer has to explicitly specify all the DPR and viewport width
combinations in the markup.</p>

<p>That would have made the Web developer's job much more difficult
and would have made the syntax much harder to grasp and significantly more verbose.</p>

<h2>Image Format Fallback</h2>

<p>One more thing you may want to do related to images (not necessarily
responsive ones) is to serve different file formats to different
browsers, according to the browser's support for them. On top of the
"traditional" file formats that browsers support (i.e. PNG, JPEG and
GIF), there are several newer file formats that browser vendors are
trying to push. These formats usually perform better than the traditional formats,
since they include all kinds of algorithmic improvements that make
image compression more efficient. Specifically, Google is pushing the
<a href="https://developers.google.com/speed/webp/">WebP</a> format and Microsoft is pushing 
<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/hh707223(v=vs.85">JPEG-XR</a>.aspx).</p>

<p>The problem here is that these new formats lack the traditional formats' level of ubiquitous support,
which means that if you serve these formats as your <code>&lt;img src&gt;</code> value, even though the browsers that support them will show an
improved user experience, the ones that don't won't show any image at
all. That's hardly good.</p>

<p>Up until today, the only way to serve such formats without breaking the
user experience in non-supporting browsers was content-negotiation,
using the "Accept" header or UA sniffing. 
While that mostly works fine, it has some caveats. It requires server-side
fiddling, which some developers can't do or lack interest in doing. It also
introduces difficulties with regard to making these images publicly cacheable.</p>

<p>With the picture syntax, we finally have a way to define a client-side
fallback mechanism. By using the <code>type</code> attribute on <code>&lt;source&gt;</code> we can 
provide the browser with multiple resource URLs, and let the browser
pick the one it supports. Such mechanisms have been
available for other resource types for
years (e.g. fonts, videos). Now a fallback mechanism is also available for images.</p>

<p>The syntax for client-side format fallback looks something like:</p>

<pre><code>&lt;picture&gt;
  &lt;source type="image/webp" srcset="president.webp"&gt;
  &lt;source type="image/vnd.ms-photo" srcset="president.jpxr"&gt;
  &lt;img src="president.jpg" alt="The president fistbumps someone."&gt;
&lt;/picture&gt;</code></pre>

<h2>Can I Use It Today?</h2>

<p>Native support for most of the features we discussed is still a few weeks away from reaching stable browsers, 
but you certainly can start using these features right now.</p>

<p>The <code>srcset</code> <code>x</code> descriptor is already supported in browsers since
Chrome 34, Opera 21 and will be supported in Safari 8.</p>

<p>Picture element support is destined to ship in a few weeks
in Chrome 38, Opera 25 and Firefox 33. The implementation of
the <code>sizes</code>/<code>srcset</code> part of the syntax in WebKit is complete, but unfortunately, it did not ship in Safari 8.
There's also still work to be done (read: I need to work on it) to implement the full <code>&lt;picture&gt;</code> syntax there.</p>

<p>Regarding IE, officially <code>&lt;picture&gt;</code> is "under consideration", but the
IE development team show up on the #respimg IRC quite often and ask good
questions. Let's hope the status will switch to "in development" shortly.</p>

<p>Picture element support was also implemented in the W3C's
<a href="http://validator.w3.org/">validator</a>, so you can use that
to spot mistakes in your markup, should you run into trouble with it.</p>

<p>The feature has a standard compliant polyfill called
<a href="http://scottjehl.github.io/picturefill/">picturefill</a>, and
even without it, the inherent <code>&lt;img&gt;</code> tag fallback makes it so that
legacy browsers would still download and
display the fallback image, meaning that the user experience in these browsers won't be any
different than what they get if you simply use an <code>&lt;img&gt;</code> tag.</p>

<h2>The Proposal Left Behind</h2>

<p>Those of you who followed the responsive images saga closely may
remember yet another proposal, called "Client-Hints".
That proposal suggested solving some of the use-cases
by using HTTP request headers to tell the server
regarding the browser's environmental conditions, and letting the server
adapt the images it sends accordingly. 
That kind of solution is generally referred to as "content-negotiation".</p>

<p>Unfortunately some browser vendors were reluctant to add new content-negotiation-based solutions, 
because of past bad experience with this kind of solutions.
Without support from these browser vendors, progress on Client-Hints
stalled and now the proposal is not being actively worked on.</p>

<h2>Community</h2>

<p>The responsive images effort, unlike the development process behind most Web platform
features, was community-driven. It was championed by the RICG,
supported by the developer community, and taken home when browser folks
got involved too. One big happy family.</p>

<p>In the same spirit, the feature's implementation in Blink (the rendering engine
behind Chrome and Opera) also set something of a precedent.</p>

<p>In order to defuse <a href="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2014-January/041833.html">initial</a> 
<a href="http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2014-January/041910.html">implementation</a> concerns from the Blink project, 
I <a href="https://groups.google.com/a/chromium.org/d/msg/blink-dev/9xIjDTOwbeI/1mL2lDYaHFYJ">devised an implementation
plan</a> with the Blink team
and started to work on related infrastructure. </p>

<p>At first, I worked on that during my free time, but later on, after I saw how long that was going to take,
I completed the feature's implementation as my day job. I was financed by the community via a <a href="https://www.indiegogo.com/projects/picture-element-implementation-in-blink">crowd funding
campaign</a>
which was put together with the help of the RICG gang (particularly 
<a href="https://twitter.com/wilto">Mat Marquis</a> and <a href="https://twitter.com/hellogeri">Geri Coady</a>). </p>

<p>Web developers, agencies, as well as Google and Opera contributed to the campaign, making it possible
for me to work full-time on the implementation, and bring it to where it is today.</p>

<h2>To Sum It Up</h2>

<p>Responsive images have been a pain point when developing responsive Web sites for quite some time. 
Now, finally, a native solution is getting close. </p>

<p>You can start using it today, with or without picturefill, and start
savings your users' time and money!</p>
