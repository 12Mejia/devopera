Title: Adding semantic sugar to XHTML
----
Date: 2008-09-07 22:13:44
----
Author: 
----
Text:

<p>The W3C has just recently made a call for review for the Proposed Recommendation of <a href="http://www.w3.org/TR/rdfa-syntax/">RDFa in XHTML: Syntax and Processing</a>.  This also includes a <a href="http://www.w3.org/2006/07/SWD/RDFa/implementation-report/">implementation report</a>.  The call for comments lasts until the 3<sup>rd</sup> of October.</p>

<p>Many of you may be asking what this means.  It is all part of the greater aims of the Semantic Web.  On the Web you have web pages, that are often made up of (X)HTML for structure, CSS for presentation and JavaScript for behaviour.  It is a best practice when writing (X)HTML to use semantic markup; to use the correct elements like the <code>h1</code> to <code>h6</code> elements for headings and <code>p</code> elements for paragraphs, and so on, while using class and ID names that describe the structure of the content rather than its presentation.  This is nice, but the semantic web tries to take this further.  With class and ID names, each person can define their own naming scheme and there is no way of knowing that my creator class means the same as your author class.  A human can fairly easily infer this, but a machine can&#39;t.  Likewise, there is information stored in HTML documents, that we as humans understand, such as <q>I had lunch with Kari yesterday noon</q>, but machines will have a hard time understanding that <q>I</q> is <em>David Storey</em>, who <q>Kari</q> is, or that <q>yesterday noon</q> was  <em>Saturday, the 6<sup>th</sup> of September, 2008</em>.  The semantic web look at ways of representing this information, so that computers can understand and process the meaning of content, and use it across domains, allowing things like Mashups to be more powerful, and data to be more portable.</p>

<p>A search engine for example could, if the data was represented correctly (we’ll come back to that in a minute), know that the subject of a photo is the Kremlin, and its exact co-ordinates.  With-in the search results for the Kremlin, it could show the photograph, pin point it on a map, and pull in related content, such a blog posts talking about the subjects, all cafes near by and so on.  This can be done today with APIs for certain services and a brute force approach by using complex and clever algorithms.  With the semantic web, this would be much simpler, and data could be taken from any page that represents its content in a semantic way, even if it doesn’t publish its own API.  If you are thinking <a href="http://microformats.org/">Microformats</a> now, you’d be part of the way correct.</p>

<p>Back when I was studying for my masters, I was introduced to the Semantic Web.  This struck me as a fantastic area of research, but it just looked too complex for the average Joe to use in their web sites.  It revolved around Ontologies which are likes catalogues that describe the meaning of terms, and data models that use terms from ontologies to describe data or content and the relationships between the data.   You could use technologies such as <a href="http://www.w3.org/2004/OWL/">OWL</a> to describe a specific ontology.  If I was in the music industry, I might want to make a record ontology which defines terms such as the record title, year of production, etc.  I could them publish this ontology for anyone to use as they see fit.  I may then find out someone else has created an ontology that describes the same thing.  It would have been better to have checked first, but now there are two ontologies describing the same kind of data, I could map the related terms together, so there is a direct relationship between my <q>song-title</q> and their <q>songtitle</q>.  As they are described as equivalent, a machine processing data using my and their onologies would know they both describe the same thing.  This is very powerful.  Writing ontologies is fairly complex, but that isn’t too much of an issue as regular web developers don’t have to create ontologies, they can find existing ontologies that describe what they are writing about instead of rolling their own.</p>

<p>The main issue comes with marking up the data with these terms, and describing the relationships between the content.  The technology to do this is <a href="http://www.w3.org/RDF/">RDF</a>.  The concept of RDF is fairly simple.  It defines triplets that describe relationships.  Anyone familiar with any form of programming, or even linguistics will find this simple.  There is the Subject, Object and Predicate. In the sentence <q>David Storey goes to the restaurant.</q> David Storey is the Subject (what/who the sentence is about), the Object is the restaurant (usually a noun or noun phrase, that is being acted on) and goes to is the predicate (a verb or verb phrase which is the action in the sentence).  RDF has many ways of representing this including N3 and RDF/XML, but like RSS they all revolve around creating a separate file to describe the structure of the content in your (X)HTML page.  This creates complexity and is a fair amount of extra work.</p>

<p>Microformats does away with the complexity by describing the semantic meaning right into the (X)HTML page itself.  They have a number of formats which are described on the wiki (rather than a formal ontology), and the terms can be added to web pages directly using existing (X)HTML attributes, such as the <code>class</code> and <code>rel</code> attributes.  This is very simple, which has aided adoption; indeed some of the biggest sites on the Web use Microformats.  They also work on the Web today.  They use existing attributes, so nothing needs to be added to a spec or the browser, and your pages will still validate.  They are not without some problems or controversy however.  The BBC <a href="http://www.bbc.co.uk/blogs/radiolabs/2008/06/removing_microformats_from_bbc.shtml">infamously removed Microformats</a> from a part of their site, claiming a part of one of the formats clashed with accessibility features.  There is also only a limited number of Microformats, and new formats have to be accepted by the Microformat community.  There is also not a general purpose Microformat parser, due to the simplicity and not having the required infrastructure in place.  A Microformats parser has to be extended every time a new format comes out.  RDF is much more complex, but it allows RDF parsers that can parse any RDF.  A new parser isn&#39;t needed every time a new ontology is created, and anyone can make a ontology to fit their needed.  Through GRDDL you can even transform Microformats into RDF.</p>

<p>In my mind Microformats showed how the semantic web could be taken beyond academia and be used i the real world, with its low barrier to entry, and while it doesn&#39;t suit all use cases, it works for many of them.  It lacks certain features, not so much due to the weaknesses of Microformats, but due to design decisions to make it as easy as possible for the majority of cases.  Lessons have been learnt in the RDF camp, and a new standard, <a href="http://www.w3.org/TR/xhtml-rdfa-primer/">RDFa</a> has been created, which takes a similar approach of including the semantics directly into the mark up.  It is slightly more complicated in that there are new attributes to learn, and more things can be described, but it is more flexible in that it can be transformed into full RDF triplets so it keeps all the power of RDF while hiding some of the complexity. As it doesn‘t have to reuse existing (X)HTML constructs, it avoids any possible accessibility pit falls, such as putting machine readable data in a attribute that a screen reader may read to a human.  The other trade off is that XHTML needs to be used (and a new doctype) as pages will not validate with RDFa attributes, and it requires namespaces so that it can link to the correct ontologies where the terms are defined.  Time will tell if RDFa succeeds in the middle ground between the power of RDF and the simplicity of Microformats.  I think it shows promise, but I’ve already studied RDFso things may seem easier.</p>

<p>One reaction that I have to RDFa is that it uses the <code>property</code> attribute in place of where the <code>class</code> attribute is often used in HTML to add semantic  meaning to what is being marked up.  It now seems a duplication of effort to add  for example a class of <q>title</q>, and a property of <q>dc:title</q> (dc in this example being the namespace that points to the <a href="http://dublincore.org/documents/dces/">Dublin Core</a> ontology).   In cases like this, you could leave off the class and use a <a href="http://www.w3.org/TR/css3-selectors/#attrnmsp">attribute selector</a> to style the item using the value of the property attribute.  For example:</p>

<p><code><pre>@namespace dc &quot;http://purl.org/dc/elements/1.1/&quot;;
[dc|property=title] { font-style: italic; }</pre></code></p>

<p>That is quite a bit more complex than just using a class selector, and the browser support isn’t as wide, but RDFa already requires XHTML so IE is already out of the picture (for now), and once it is memorised it isn’t too difficult.  It is also worth noting that RDFa is part of the work the <a href="http://www.w3.org/2007/03/XHTML2-WG-charter">XHTML2 working group</a> is undertaking.  This is the second spec that has been back-ported from XHTML2 into XHTML1.1, via modularisation. The first was WAI-ARIA, which has already been implemented by a number of browsers.  It will be interesting to see if it gets added to HTML5. If you are interested in RDFa then read the <a href="www.w3.org/TR/xhtml-rdfa-primer">RDFa primer</a> to learn more on what it is and how to use it.</p>
